// SPDX-FileCopyrightText: 2021 Open Networking Foundation <info@opennetworking.org>
// SPDX-FileCopyrightText: 2024 Canonical Ltd
// SPDX-License-Identifier: Apache-2.0

/*
 * Connectivity Service Configuration
 *
 * APIs to configure connectivity service in Aether Network
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package configapi

import (
	"encoding/json"
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/omec-project/webconsole/backend/logger"
	"github.com/omec-project/webconsole/configmodels"
	"github.com/omec-project/webconsole/dbadapter"
	"go.mongodb.org/mongo-driver/bson"
	"net/http"
)

const (
	devGroupDataColl = "webconsoleData.snapshots.devGroupData"
	sliceDataColl    = "webconsoleData.snapshots.sliceData"
	amDataColl       = "subscriptionData.provisionedData.amData"
	smDataColl       = "subscriptionData.provisionedData.smData"
	smfSelDataColl   = "subscriptionData.provisionedData.smfSelectionSubscriptionData"
	amPolicyDataColl = "policyData.ues.amData"
	smPolicyDataColl = "policyData.ues.smData"
	authSubsDataColl = "subscriptionData.authenticationData.authenticationSubscription"
)

// GetDeviceGroups godoc
//
// @Description  Return the list of device groups
// @Tags         Device Groups
// @Produce      json
// @Security     BearerAuth
// @Success      200  {array}   string  "List of device group names"
// @Failure      401  {object}  nil     "Authorization failed"
// @Failure      403  {object}  nil     "Forbidden"
// @Failure      500  {object}  nil     "Error retrieving device groups"
// @Router       /config/v1/device-group/  [get]
func GetDeviceGroups(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get all Device Groups")

	deviceGroups := make([]string, 0)
	rawDeviceGroups, errGetMany := dbadapter.CommonDBClient.RestfulAPIGetMany(devGroupDataColl, bson.M{})
	if errGetMany != nil {
		logger.DbLog.Warnln(errGetMany)
	}
	for _, rawDeviceGroup := range rawDeviceGroups {
		deviceGroups = append(deviceGroups, rawDeviceGroup["group-name"].(string))
	}

	c.JSON(http.StatusOK, deviceGroups)
}

// GetDeviceGroupByName godoc
//
// @Description  Return the device group
// @Tags         Device Groups
// @Param        deviceGroupName    path    string    true    " "
// @Produce      json
// @Security     BearerAuth
// @Success      200  {object}  configmodels.DeviceGroups  "Device group"
// @Failure      401  {object}  nil                        "Authorization failed"
// @Failure      403  {object}  nil                        "Forbidden"
// @Failure      404  {object}  nil                        "Device group not found"
// @Failure      500  {object}  nil                        "Error retrieving device group"
// @Router       /config/v1/device-group/{deviceGroupName}  [get]
func GetDeviceGroupByName(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get Device Group by name")

	var deviceGroup configmodels.DeviceGroups
	filter := bson.M{"group-name": c.Param("group-name")}
	rawDeviceGroup, errGetOne := dbadapter.CommonDBClient.RestfulAPIGetOne(devGroupDataColl, filter)
	if errGetOne != nil {
		logger.DbLog.Warnln(errGetOne)
	}
	err := json.Unmarshal(configmodels.MapToByte(rawDeviceGroup), &deviceGroup)
	if err != nil {
		logger.DbLog.Errorw("failed to unmarshal device group", "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to retrieve device group"})
		return
	}
	if deviceGroup.DeviceGroupName == "" {
		c.JSON(http.StatusNotFound, nil)
	} else {
		c.JSON(http.StatusOK, deviceGroup)
	}
}

// DeviceGroupGroupNameDelete godoc
//
// @Description  Delete an existing device group
// @Tags         Device Groups
// @Param        deviceGroupName    path    string    true    " "
// @Security     BearerAuth
// @Success      200  {object}  nil  "Device group deleted successfully"
// @Failure      400  {object}  nil  "Bad request"
// @Failure      401  {object}  nil  "Authorization failed"
// @Failure      403  {object}  nil  "Forbidden"
// @Failure      500  {object}  nil  "Device Group Deletion Failed"
// @Router       /config/v1/device-group/{deviceGroupName}  [delete]
func DeviceGroupGroupNameDelete(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNameDelete")
	groupName := c.Param("group-name")
	if groupName == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "group-name is not provided"})
		return
	}
	if err := deviceGroupDeleteHelper(groupName); err != nil {
		logger.ConfigLog.Errorf("Device group delete failed: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Device group delete failed. Please check the log for details"})
		return
	}
	c.JSON(http.StatusOK, gin.H{})
}

// DeviceGroupGroupNamePut -
func DeviceGroupGroupNamePut(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNamePut")
	groupName := c.Param("group-name")
	if groupName == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "group-name is not provided"})
		return
	}
	if !isValidName(groupName) {
		logger.ConfigLog.Errorf("invalid Device Group name %s. Name needs to match the following regular expression: %s", groupName, NAME_PATTERN)
		c.JSON(http.StatusBadRequest, gin.H{
			"error": fmt.Sprintf(
				"Invalid Device Group name %s. Name needs to match the following regular expression: %s",
				groupName, NAME_PATTERN,
			),
		})
		return
	}
	if err := deviceGroupPostHelper(c, configmodels.Put_op, groupName); err != nil {
		logger.ConfigLog.Errorf("Device group update failed: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Device group update failed. Please check the log for details"})
		return
	}
	c.JSON(http.StatusOK, gin.H{})
}

// DeviceGroupGroupNamePost godoc
//
// @Description  Create a new device group
// @Tags         Device Groups
// @Param        deviceGroupName    path    string                       true    " "
// @Param        content            body    configmodels.DeviceGroups    true    " "
// @Security     BearerAuth
// @Success      200  {object}  nil  "Device group created"
// @Failure      400  {object}  nil  "Invalid device group content"
// @Failure      401  {object}  nil  "Authorization failed"
// @Failure      403  {object}  nil  "Forbidden"
// @Failure      409  {object}  nil  "Device group exists"
// @Failure      500  {object}  nil  "Error creating device group"
// @Router       /config/v1/device-group/{deviceGroupName}  [post]
func DeviceGroupGroupNamePost(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNamePost")
	groupName := c.Param("group-name")
	if groupName == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "group-name is not provided"})
		return
	}
	if !isValidName(groupName) {
		logger.ConfigLog.Errorf("invalid Device Group name %s. Name needs to match the following regular expression: %s", groupName, NAME_PATTERN)
		c.JSON(http.StatusBadRequest, gin.H{
			"error": fmt.Sprintf(
				"Invalid Device Group name %s. Name needs to match the following regular expression: %s",
				groupName, NAME_PATTERN,
			),
		})
		return
	}
	if err := deviceGroupPostHelper(c, configmodels.Post_op, groupName); err != nil {
		logger.ConfigLog.Errorf("Device group create failed: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Device group create failed. Please check the log for details"})
		return
	}
	c.JSON(http.StatusOK, gin.H{})
}

// GetNetworkSlices godoc
//
// @Description  Return the list of network slices
// @Tags         Network Slices
// @Produce      json
// @Security     BearerAuth
// @Success      200  {array}   string  "List of network slice names"
// @Failure      401  {object}  nil     "Authorization failed"
// @Failure      403  {object}  nil     "Forbidden"
// @Failure      500  {object}  nil     "Error retrieving network slices"
// @Router       /config/v1/network-slice/  [get]
func GetNetworkSlices(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get all Network Slices")

	networkSlices := make([]string, 0)
	rawNetworkSlices, errGetMany := dbadapter.CommonDBClient.RestfulAPIGetMany(sliceDataColl, bson.M{})
	if errGetMany != nil {
		logger.DbLog.Warnln(errGetMany)
	}
	for _, rawNetworkSlice := range rawNetworkSlices {
		networkSlices = append(networkSlices, rawNetworkSlice["slice-name"].(string))
	}

	c.JSON(http.StatusOK, networkSlices)
}

// GetNetworkSliceByName godoc
//
// @Description  Return the network slice
// @Tags         Network Slices
// @Produce      json
// @Param        sliceName    path    string    true    " "
// @Security     BearerAuth
// @Success      200  {object}  configmodels.Slice  "Network slice"
// @Failure      401  {object}  nil                 "Authorization failed"
// @Failure      403  {object}  nil                 "Forbidden"
// @Failure      404  {object}  nil                 "Network slices not found"
// @Failure      500  {object}  nil                 "Error retrieving network slice"
// @Router       /config/v1/network-slice/{sliceName}  [get]
func GetNetworkSliceByName(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get Network Slice by name")

	var networkSlice configmodels.Slice
	filter := bson.M{"slice-name": c.Param("slice-name")}
	rawNetworkSlice, errGetOne := dbadapter.CommonDBClient.RestfulAPIGetOne(sliceDataColl, filter)
	if errGetOne != nil {
		logger.DbLog.Warnln(errGetOne)
	}
	err := json.Unmarshal(configmodels.MapToByte(rawNetworkSlice), &networkSlice)
	if err != nil {
		logger.DbLog.Errorw("failed to unmarshal network slice", "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to retrieve network slice"})
		return
	}
	if networkSlice.SliceName == "" {
		c.JSON(http.StatusNotFound, nil)
	} else {
		c.JSON(http.StatusOK, networkSlice)
	}
}

// NetworkSliceSliceNameDelete godoc
//
// @Description  Delete an existing network slice
// @Tags         Network Slices
// @Produce      json
// @Param        sliceName    path    string    true    " "
// @Security     BearerAuth
// @Success      202  {object}  nil  "Network slice deleted successfully"
// @Failure      400  {object}  nil  "Invalid network slice name provided"
// @Failure      401  {object}  nil  "Authorization failed"
// @Failure      403  {object}  nil  "Forbidden"
// @Failure      500  {object}  nil  "Error deleting network slice"
// @Router      /config/v1/network-slice/{sliceName}  [delete]
func NetworkSliceSliceNameDelete(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNameDelete ")
	sliceName := c.Param("slice-name")
	if sliceName == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "slice-name is not provided"})
		return
	}
	if !isValidName(sliceName) {
		logger.ConfigLog.Errorf("invalid Network Slice name %s. Name needs to match the following regular expression: %s", sliceName, NAME_PATTERN)
		c.JSON(http.StatusBadRequest, gin.H{
			"error": fmt.Sprintf(
				"Invalid slice name %s. Name needs to match the following regular expression: %s",
				sliceName, NAME_PATTERN,
			),
		})
		return
	}
	if err := networkSliceDeleteHelper(sliceName); err != nil {
		logger.ConfigLog.Errorf("Network slice delete failed: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": fmt.Sprintf("Failed to delete network slice %s. Please check the log for details.", sliceName),
		})
		return
	}
	c.JSON(http.StatusOK, gin.H{})
}

// NetworkSliceSliceNamePost godoc
//
// @Description  Create a new network slice
// @Tags         Network Slices
// @Param        sliceName    path    string                true    " "
// @Param        content      body    configmodels.Slice    true    " "
// @Security     BearerAuth
// @Success      200  {object}  nil  "Network slice created"
// @Failure      400  {object}  nil  "Invalid network slice content"
// @Failure      401  {object}  nil  "Authorization failed"
// @Failure      403  {object}  nil  "Forbidden"
// @Failure      409  {object}  nil  "Resource Conflict"
// @Failure      500  {object}  nil  "Error creating network slice"
// @Router       /config/v1/network-slice/{sliceName}  [post]
func NetworkSliceSliceNamePost(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNamePost ")
	sliceName, _ := c.Params.Get("slice-name")
	if sliceName == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "slice-name is not provided"})
		return
	}
	if !isValidName(sliceName) {
		logger.ConfigLog.Errorf("invalid Network Slice name %s. Name needs to match the following regular expression: %s", sliceName, NAME_PATTERN)
		c.JSON(http.StatusBadRequest, gin.H{
			"error": fmt.Sprintf(
				"Invalid slice name %s. Name needs to match the following regular expression: %s",
				sliceName, NAME_PATTERN,
			),
		})
		return
	}
	if err := networkSlicePostHelper(c, configmodels.Post_op, sliceName); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to create network slice %s. Please check the log for details.", sliceName)})
		return
	}
	c.JSON(http.StatusOK, gin.H{})
}

// NetworkSliceSliceNamePut -
func NetworkSliceSliceNamePut(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNamePut ")
	sliceName, _ := c.Params.Get("slice-name")
	if sliceName == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "slice-name is not provided"})
		return
	}
	if !isValidName(sliceName) {
		logger.ConfigLog.Errorf("invalid Network Slice name %s. Name needs to match the following regular expression: %s", sliceName, NAME_PATTERN)
		c.JSON(http.StatusBadRequest, gin.H{
			"error": fmt.Sprintf(
				"Invalid slice name %s. Name needs to match the following regular expression: %s",
				sliceName, NAME_PATTERN,
			),
		})
		return
	}
	if err := networkSlicePostHelper(c, configmodels.Put_op, sliceName); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to update network slice %s. Please check the log for details.", sliceName)})
		return
	}
	c.JSON(http.StatusOK, gin.H{})
}
